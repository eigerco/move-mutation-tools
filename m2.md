# Finding the Gaps: Mutation Testing for Move with move-mutation-tools

In a [previous blog post](https://medium.com/aptoslabs/specification-testing-for-move-3ef8b5ced1f9), we explained the concept of mutation testing. Here we'll expand on
that and explain new developments done to the tool.

## Quick refresher: What mutation testing does

Mutation testing deliberately introduces small, controlled bugs (mutants) into your Move code — changing an operator, constant, or condition — and re-runs your test suite.

If a test fails, the mutant is killed. If all tests still pass, the mutant survives.

Surviving mutants expose blind spots in your test suite — logic that could break without your tests noticing.

Example:

`assert!(signer::address_of(admin) == @decibel_dex, EINVALID_ADDRESS);`

A mutant might flip the comparison:

`assert!(signer::address_of(admin) != @decibel_dex, EINVALID_ADDRESS);`

If your tests never call this function with the wrong signer, this mutant will survive — revealing that your test suite doesn’t verify access control properly.

## New Features

### Modes

To optimize mutation testing by selecting operators based on their ability to detect test gaps, use the `--mode` option. Operators that produce more surviving mutants are more effective at revealing gaps in test coverage, as surviving mutants indicate untested code paths.

```bash
# Light mode - operators optimized for detecting test gaps with fewest mutants
move-mutation-test run --output report.json --mode light

# Medium mode - light + additional operators for broader test gap detection
move-mutation-test run --output report.json --mode medium

# Medium-only mode - only the operator added in medium (not including light)
move-mutation-test run --output report.json --mode medium-only

# Heavy mode - default, all operators for maximum test gap detection
move-mutation-test run --output report.json --mode heavy

# Heavy-only mode - only the operators added in heavy (not including light/medium)
move-mutation-test run --output report.json --mode heavy-only
```

The modes include:

- **light**: `binary_operator_swap`, `break_continue_replacement`, `delete_statement` (3 operators)
- **medium**: light + `literal_replacement` (4 operators)
- **medium-only**: `literal_replacement` (1 operator - only what's added in medium)
- **heavy**: all 7 operators
- **heavy-only**: `unary_operator_replacement`, `binary_operator_replacement`, `if_else_replacement` (3 operators - only what's added in heavy)

The tool is quite resource-heavy and time-expensive, so the recommendation on how to use it most efficiently is:

- run light mode and resolve the alive mutants
- run medium-only mode and resolve the alive mutants
- run heavy-only mode and resolve the alive mutants

---

For fine-grained control over which operators to apply, use the `--operators` option with a comma-separated list:

```bash
move-mutation-test run --output report.json --operators delete_statement,binary_operator_replacement,if_else_replacement
```

Available operators: `unary_operator_replacement`, `delete_statement`, `break_continue_replacement`, `binary_operator_replacement`,
`if_else_replacement`, `literal_replacement`, `binary_operator_swap`.

**Note:** The `--mode` and `--operators` options are mutually exclusive.

### Performance

To speed up mutation testing, we added a `--fail-fast` option to `move-mutation-test`. This stops test execution as soon as a test fails
(indicating that the mutant was caught). The default value is `true`, but it can be turned off if desired.

## Case Study

We ran the tool on a large Move project, splitting up the test into 3 runs, light, medium-only and heavy-only.

| Mode        | Mutants Alive | Mutants Killed | Percentage Alive |
| ----------- | ------------- | -------------- | ---------------- |
| light       | 88            | 353            | 20 %             |
| medium-only | 1155          | 1458           | 44 %             |
| heavy-only  | 1088          | 3952           | 22 %             |

### Examples per operator

The following chapter presents a selection of real, surviving mutants from actual projects, with a few examples provided per operator, as it is not feasible to cover all 2000+ mutants.

#### binary_operator_swap

This mutation operator swaps the arguments of binary operators. For example, the `a - b` expression can be replaced with the `b - a` expression.

Nearly all of these are test gaps. There are a few false positives (swap of operands on `&&` or `||` operator), severity should be assessed on a case by case basis.

The loop in the following example would likely have zero iterations, but probably unlikely to be introduced by accident, as it would immediately look 'wrong' to a developer.

```move
dex_accounts::bulk_cancel_client_and_place_order_to_subaccount: Alive mutant
--- original
+++ modified
@@ -508,7 +508,7 @@

         let i = 0;
         let len = place_prices.length();
-        while (i < len) {
+        while (len < i) {
             let price = place_prices[i];
             let size = place_sizes[i];
             let is_buy = place_is_buys[i];

```

Another example, here the tests should assert that the remaining size is correctly calculated:

```move
async_matching_engine::trigger_pending_twap: Alive mutant
--- original
+++ modified
@@ -840,7 +840,7 @@
                 account,
                 order_id,
                 orig_size,
-                remaining_size: twap_size - total_fill_size,
+                remaining_size: total_fill_size - twap_size,
                 is_buy,
                 is_reduce_only,
                 twap_start_time_s,
```

#### delete_statement

This operator deletes entire statements.

In this example, tests should assert that this move to global storage has happened.

```move
position_tp_sl_tracker::register_market: Alive mutant
--- original
+++ modified
@@ -56,13 +56,7 @@
     }

     public(package) fun register_market(market_signer: &signer) {
-        move_to(
-            market_signer,
-            PendingOrderTracker {
-                price_move_up_index: new_default_big_ordered_map(),
-                price_move_down_index: new_default_big_ordered_map()
-            }
-        )
+        {}
     }
```

Another example, tests don't assert that an abort happens:

```move
builder_code_registry::revoke_max_fee: Alive mutant
--- original
+++ modified
@@ -91,7 +91,7 @@
         let key = BuilderAndAccount { account: user_address, builder };
         let approved_max_fees = registry.approved_max_fees.get(&key);
         if (approved_max_fees.is_none()) {
-            abort error::invalid_argument(EINSUFFICIENT_BALANCE);
+            {};
         };
         registry.approved_max_fees.remove(&key);
     }
```

#### break_continue_replacement

This mutation operator replaces or deletes break/continue statements with other break/continue statements.

If this break statement were lost, the semantics would probably no longer be valid.

```move
pending_order_tracker::remove_reduce_only_order: Alive mutant
--- original
+++ modified
@@ -321,7 +321,7 @@
             if (&reduce_only_orders.orders[i].order_id == &order_id) {
                 reduce_only_orders.total_size -= reduce_only_orders.orders[i].size;
                 reduce_only_orders.orders.remove(i);
-                break;
+                {};
             };
             i += 1
         };
```

#### literal_replacement

This mutation operator replaces literals with other literals. For example, the `0` literal can be replaced
with the `1` literal or other random literal, `true` to `false`, etc. This mutation operator can also replace addresses with other addresses.

Many of the alive mutants are issues with not checking the correct error code, like here:

```move
backstop_liquidator_profit_tracker::initialize: Alive mutant
--- original
+++ modified
@@ -32,7 +32,7 @@
     public fun initialize(admin: &signer) {
         assert!(
             signer::address_of(admin) == @decibel_dex,
-            EINVALID_ADDRESS
+            0
         );

         move_to(
```

This one is probably worse:

```move
backstop_liquidator_profit_tracker::get_liquidation_position_data: Alive mutant
--- original
+++ modified
@@ -238,7 +238,7 @@
         let tracker = get_tracker();

         if (!tracker.market_data.contains(market)) {
-            return (0, 0, false)
+            return (340282366920938463463374607431768211455, 0, false)
         };

         let market_data = tracker.market_data.borrow(market);
```

#### binary_operator_replacement

This mutation operator replaces binary operators with other binary operators. For example, the `+` operator can be replaced with the `-` operator.

Operators are grouped into the following categories:

    arithmetic operators: +, -, *, /, %
    bitwise operators: &, |, ^
    shifts: <<, >>
    comparison operators: ==, !=, <, >, <=, >=
    logical operators: &&, ||

Operators are replaced within the same category. For example, the `+` operator can be replaced with the `-` operator, but not the `<<` operator.

The alive mutants are probably all test gaps, and there are many like these:

```move
backstop_liquidator_profit_tracker::calculate_pnl: Alive mutant
--- original
+++ modified
@@ -207,7 +207,7 @@
             if (is_long) {
                 exit_price >= entry_price
             } else {
-                exit_price <= entry_price
+                exit_price > entry_price
             };

         if (is_profit) {
```

```move
backstop_liquidator_profit_tracker::track_position_update: Alive mutant
--- original
+++ modified
@@ -133,7 +133,7 @@
         if (size > market_data.liquidation_size) {
             // New position completely nets out existing position
             let existing_size = market_data.liquidation_size;
-            let remaining_size = size - existing_size;
+            let remaining_size = size + existing_size;

             // Handle PnL from netting
```

This one seems to be a security issue:

```move
decibel_time::init_module: Alive mutant
--- original
+++ modified
@@ -14,7 +14,7 @@

     fun init_module(deployer: &signer) {
         assert!(
-            signer::address_of(deployer) == @decibel_dex, EINVALID_AUTHORIZED_ACCOUNT
+            signer::address_of(deployer) != @decibel_dex, EINVALID_AUTHORIZED_ACCOUNT
         );
         move_to(deployer, TimeOverride { time_us: option::none() });
     }
```

#### unary_operator_replacement

This mutation operator replaces unary operators with other unary operators. For example, the `!` operator can be replaced with a whitespace.

Most mutants with this mutation are caught, but some are alive:

```move
i64::is_negative: Alive mutant
--- original
+++ modified
@@ -204,7 +204,7 @@
     }

     public(package) fun is_negative(self: &I64): bool {
-        !self.is_positive
+         self.is_positive
     }
```

#### if_else_replacement

This mutation operator replaces `if-else` expressions with constant boolean values. For example, the `if (cond) { ... } else { ... }`
expression can be replaced with the `if (false) { ... } else { ... }` expression.

In this function, mutants with `true` and `false` both survive, which indicates this function is not properly tested:

```move
i64::max: Alive mutant
--- original
+++ modified
@@ -133,7 +133,7 @@
     public(package) fun max(lhs: I64, rhs: I64): I64 {
         if (lhs.is_positive && rhs.is_positive) {
             // Both positive, return larger amount
-            if (lhs.amount >= rhs.amount) { lhs }
+            if (true) { lhs }
             else { rhs }
         } else if (!lhs.is_positive && !rhs.is_positive) {
             // Both negative, return smaller absolute value
```

```move
i64::max: Alive mutant
--- original
+++ modified
@@ -133,7 +133,7 @@
     public(package) fun max(lhs: I64, rhs: I64): I64 {
         if (lhs.is_positive && rhs.is_positive) {
             // Both positive, return larger amount
-            if (lhs.amount >= rhs.amount) { lhs }
+            if (false) { lhs }
             else { rhs }
         } else if (!lhs.is_positive && !rhs.is_positive) {
             // Both negative, return smaller absolute value
```

## Try It!

Try it on your Move project:

```bash
# install the tool via aptos CLI
aptos update move-mutation-test
# generate coverage report
aptos move test --coverage
# run the tool
move-mutation-test run --coverage --output output.json
# visualize the results
move-mutation-test display-report mutants --path-to-report output.json
```

Review the alive mutants and write targeted tests.

Rerun to see the improvement — the number of alive mutants should drop.

Mutation testing isn’t about more tests — it’s about better tests.
With move-mutation-tools, you’ll see exactly where your Move code’s correctness guarantees end, and your untested assumptions begin.

For more details and source code, see [Eiger’s GitHub repository](https://github.com/eigerco/move-mutation-tools).
